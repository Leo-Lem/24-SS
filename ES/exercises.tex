\documentclass{article}

\usepackage[solutions]{../.template/xrcise}

\subject{Eingebettete Systeme}
\semester{Summer 2024}
\author{Leopold Lemmermann}

\begin{document}\createtitle

\sheet{Mündliche Prüfung}
\begin{exercise}{Path}
  \begin{enumerate}
    \item Was sind die wichtigsten Eigenschaften eingebetteter Systeme?
          \begin{solution}
            Echtzeitfähigkeit, Energieeffizienz, Ressourcenknappheit, Zuverlässigkeit. -> Auf Entwicklungsprozess eingehen und OS genauer eingehen.
          \end{solution}

    \item Sie sind kurz auf die Entwicklung eingegangen. Können Sie das genauer erläutern?
          \begin{solution}
            nach Vorlesung: Requirements/Modellierung (MoC erwähnen und Kommunikation), Hardware/Software, iteratives Application Mapping/Evaluation+Validation/Optimierung.
            Tests in allen Schritten (TDD) -> V-Modell: Requirements (Acceptance), System Design (Hardware, Software/OS) (System tests), Software Architecture (Integration), Software Design (Unit), Coden.
          \end{solution}

    \item Sie haben die Models of Computation erwähnt. Welche gibt es und wie kommunizieren sie?
          \begin{solution}
            Communicating FSMs, Data flow, Petrinetze, Diskrete Eventmodelle (DE models) und das klassische von Neumann Modell. Sie kommunizieren über Shared Memory und Message Passing.
          \end{solution}

    \item Erklären Sie gerne ein Modell genauer.
          \begin{solution}
            Communicating FSMs mit StateCharts. Hierarchie und Parallelität. Kommunikation mittels Shared Memory zwischen Zuständen.
          \end{solution}

    \item Sie hatten vorhin auch kurz eingebettete Betriebssysteme erwähnt. Worin unterscheiden sich diese von Allzweckbetriebssystemen?
          \begin{solution}
            Eingebettete Betriebssysteme sind speziell für die Anforderungen von eingebetteten Systemen optimiert und unterscheiden sich in Ihrer Echtzeitfähigkeit, darin, dass jeder Prozess Interrupts auslösen kann, und, dass zumeist direkt mit der Hardware kommuniziert wird (und nicht über das OS). Außerdem wird angenommen, dass Software getestet ist und somit weniger Sicherheitsanforderungen durch das OS gestellt werden. -> Ansonsten kümmern sich Betriebssysteme um eine Benutzeroberfläche, aber insb. Ressourcenverwaltung inkl. Scheduling.
          \end{solution}

    \item Welche Eigenschaften haben Schedules bzw. Scheduling-Verfahren? Erklären Sie diese gerne an einem Beispiel.
          \begin{solution}
            Periodizität, Dependenz, Präemption, Dynamik. Rate Monotonic Scheduling ist ein periodisches, nicht-dependentes, nicht-präemptives, und statisches Scheduling-Verfahren, bei dem die Priorität eines Prozesses durch seine Rate bestimmt wird. Die Rate eines Prozesses ist der Kehrwert seiner Periode.
          \end{solution}

    \item Im Designfluss haben Sie Optimierung erwähnt. Wonach wird denn typischerweise optimiert und wie?
          \begin{solution}
            Typischerweise wird nach Performance, Energieeffizienz, und Speicherbedarf optimiert. Dies erfolgt durch Hardwareauswahl, Codeoptimierung, und Dynamic Power Management. Auf Softwareebene Loop Unrolling, Loop Tiling, Loop Fusion/Loop Fission.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{Einführungsfragen}
  \begin{enumerate}
    \item Wie würden Sie (generell) an den Entwurf eines eingebetteten Systems herangehen?

          \begin{solution}
            Beim Entwurf von eingebetteten System startet man (wie bei jedem Entwurf) mit einer Anforderungsanalyse und darauf basierend eine Spezifikation. Anschließend folgt die Modellierung. Bei ES insbesondere, muss nun auch Hard- und Software spezifiziert werden (da diese häufig genau auf das System angepasst werden muss). Dies erfolgt alles iterativ, zusammengefasst: Requirements, System Architecture, System Design, Software Architecture, Software Design. Natürlich sollten optimalerweise in jedem Schritt auch Tests durchgeführt werden, aber zumindest vor Release.
          \end{solution}

    \item Was sind die wichtigsten Unterschiede zwischen eingebetteten Systemen und Allzweckcomputern?

          \begin{solution}
            Die wichtigsten Unterschiede zwischen eingebetteten Systemen und Allzweckcomputern sind die Echtzeitfähigkeit, die Ressourcenknappheit, und die Energieeffizienz.
          \end{solution}

    \item Was unterscheidet eingebettete Betriebssysteme von Allzweckbetriebssystemen?

          \begin{solution}
            Eingebettete Betriebssysteme sind speziell für die Anforderungen von eingebetteten Systemen optimiert und unterscheiden sich in Ihrer Echtzeitfähigkeit, darin, dass jeder Prozess Interrupts auslösen kann, und, dass zumeist direkt mit der Hardware kommuniziert wird (und nicht über das OS). Außerdem wird angenommen, dass Software getestet ist und somit weniger Sicherheitsanforderungen durch das OS gestellt werden.
          \end{solution}

    \item Welche Models of Computation (MoCs) sind für eingebettete Systeme relevant und wie kommunizieren sie?

          \begin{solution}
            Models of Computation (MoCs) für eingebettete Systeme sind z.B. Communicating FSMs, Data flow, Petrinetze, Diskrete Eventmodelle (DE models) und das klassische von Neumann Modell. Sie kommunizieren über Shared Memory und Message Passing.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{Reliability}
  \begin{enumerate}
    \item Was versteht man unter Zuverlässigkeit von Embedded Systems und wie kann man diese messen?

          \begin{solution}
            Zuverlässigkeit beschreibt die Fähigkeit eines Systems, eine bestimmte Funktion unter spezifizierten Bedingungen für eine definierte Zeitdauer zu erfüllen. Sie kann durch Zuverlässigkeitstests gemessen werden und durch den FIT (Fault in Time) formalisiert werden. Dieser gibt die Anzahl der Ausfälle pro Milliarde Betriebsstunden an.
          \end{solution}
    \item Was beschreibt der Fault in Time (FIT) Wert und wie wird dieser bestimmt?

          \begin{solution}
            Der FIT-Wert gibt die Anzahl der Ausfälle pro Milliarde Betriebsstunden an und ist ein Maß für die Zuverlässigkeit eines Systems. Er wird durch Zuverlässigkeitstests bestimmt.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{OS}
  \begin{enumerate}
    \item Was macht Interrupts und ihre Behandlung in einem ES aus?

          \begin{solution}
            Interrupts können nicht nur vom Betriebssystem, sondern auch von anderen Komponenten des Systems ausgelöst werden. Die Behandlung von Interrupts in einem ES ist kritisch, da sie die Echtzeitfähigkeit des Systems beeinflussen können.
          \end{solution}

    \item Was machen Betriebsysteme noch?

          \begin{solution}
            Betriebssysteme verwalten Ressourcen wie Prozessoren, Speicher und Geräte, bieten Schnittstellen für Anwendungen und sorgen für die Sicherheit und Zuverlässigkeit des Systems.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{MoCs}
  \begin{enumerate}
    \item Erklären Sie ein MoC Ihrer Wahl genauer.

          \begin{solution}
            Hierfür eignen sich zB. die Communicating FSMs. Das lässt sich für Shared Memory Kommunikation mit StateCharts umsetzen. StateCharts erweitert klassische endliche Automaten um Hierarchie und Parallelität. Durch Kommunikation zwischen den Zuständen können Informationen ausgetauscht werden.
          \end{solution}

    \item Beschreiben Sie kurz, was Shared Memory und Message Passing sind.

          \begin{solution}
            Shared Memory: Shared Memory ist eine Kommunikationstechnik, bei der mehrere Prozesse auf gemeinsame Speicherbereiche zugreifen können.
            Message Passing: Message Passing ist eine Kommunikationstechnik, bei der Prozesse Nachrichten austauschen, um Daten zu übertragen.
          \end{solution}

    \item Was sind die Vor- und Nachteile von Shared Memory bzw. Message Passing?

          \begin{solution}
            Shared Memory ist schneller, aber schwieriger zu implementieren und weniger sicher.
            Message Passing ist sicherer und intuitiver, aber langsamer und erfordert mehr Ressourcen.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{Scheduling}
  \begin{enumerate}
    \item Was sind die 4 Eigenschaften von Scheduling-Verfahren? Beschreiben Sie diese kurz.

          \begin{solution}
            Periodizität, Dependenz, Präemption, Dynamik.
            Periodizität beschreibt die Regelmäßigkeit, mit der ein Prozess ausgeführt wird.
            Dependenz beschreibt die Abhängigkeit eines Prozesses von anderen Prozessen.
            Präemption beschreibt die Möglichkeit, einen Prozess zu unterbrechen und später fortzusetzen.
            Dynamik beschreibt die Fähigkeit eines Scheduling-Verfahrens, sich an Änderungen in der Umgebung anzupassen.
          \end{solution}

    \item Stellen Sie einen Algorithmus vor.

          \begin{solution}
            Rate Monotonic Scheduling ist ein deterministisches, präemptives Scheduling-Verfahren, bei dem die Priorität eines Prozesses durch seine Rate bestimmt wird. Die Rate eines Prozesses ist der Kehrwert seiner Periode.
          \end{solution}

    \item Was ist Priority Inversion und wie kann man das vermeiden?

          \begin{solution}
            Priority Inversion tritt auf, wenn ein niedrig priorisierter Prozess eine Ressource blockiert, die von einem höher priorisierten Prozess benötigt wird. Priority Inversion kann durch die Verwendung von einer Priority Ceiling vermieden werden.
            Priority Ceiling ist eine Technik, bei der die Priorität eines Prozesses auf das Maximum der Prioritäten der Prozesse gesetzt wird, die auf die gleiche Ressource warten.
          \end{solution}

    \item Was kann noch für ein Problem auftreten und wie vermeidet man das?

          \begin{solution}
            Deadlocks können auftreten, wenn Prozesse auf gegenseitige Exklusivität warten. Deadlocks können durch die Vermeidung von zyklischen Wartebedingungen vermieden werden.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{Optimierung}
  \begin{enumerate}
    \item Nennen Sie einige High-Level Softwareoptimierungen und erklären Sie diese kurz!

          \begin{solution}
            Loop Unrolling, Loop Tiling, Loop Fusion/Loop Fission.
            Loop Unrolling wird angewendet, um den Overhead von Schleifen zu reduzieren und die Parallelität von Instruktionen zu erhöhen. Hierbei wird der Schleifenkörper mehrfach kopiert und die Schleifenvariable entsprechend angepasst.
            Loop Tiling wird angewendet, um den Cache-Effekt zu verbessern und die Parallelität von Instruktionen zu erhöhen. Hierbei wird der Schleifenkörper in kleinere Teile aufgeteilt, die sequentiell ausgeführt werden.
            Loop Fusion/Loop Fission wird angewendet, um den Overhead von Schleifen zu reduzieren und die Parallelität von Instruktionen zu erhöhen. Hierbei werden mehrere Schleifen zu einer Schleife zusammengefasst oder eine Schleife in mehrere Schleifen aufgeteilt.
            Die meisten dieser Optimierungen werden allerdings durch den Compiler bereits vorgenommen und in vielen Fällen führt eine manuelle Implementierung sogar zu schlechterer Performance.

          \end{solution}

    \item Weswegen würde man Loop Unrolling anwenden?

          \begin{solution}
            Loop Unrolling wird angewendet, um den Overhead von Schleifen zu reduzieren und die Parallelität von Instruktionen zu erhöhen.
          \end{solution}

    \item Nennen Sie einige Energieeffizienzoptimierungen.

          \begin{solution}
            Hardwareauswahl, Codeoptimierung, Dynamic Power Management (low power oder sleep mode).
          \end{solution}

    \item Was gibt es für Ansätze um hardware-seitig für ES zu optimieren?

          \begin{solution}
            FPGAs, ASICs, VLIW-Prozessoren, Single-ISA heterogeneous multi-core architectures, GPUs, MPSoCs.
            FPGAs (Field Programmable Gate Arrays) beschreiben die Umsetzung von im Vorhinein bekannter Applikationslogik auf Hardwareebene mittels Logik-/Speicherblöcken und Verbindungen.
            ASICs (Application Specific Integrated Circuits) sind speziell für eine Anwendung entwickelte Chips.
            VLIW-Prozessoren (Very Long Instruction Word) führen mehrere Instruktionen in einem Taktzyklus aus.
            Single-ISA heterogeneous multi-core architectures sind Architekturen, bei denen mehrere Prozessoren mit unterschiedlichen Eigenschaften auf einem Chip integriert sind.
            GPUs (Graphics Processing Units) sind Prozessoren, die für die parallele Verarbeitung optimiert sind und insb. für Grafikanwendungen verwendet werden.
            MPSoCs (Multiprocessor Systems-on-Chip) sind Multiprozessorsysteme auf einem Chip, die für die Verarbeitung von Signalen und Daten optimiert sind.
          \end{solution}
  \end{enumerate}
\end{exercise}

\sheet{Marwedel}
\begin{exercise}{Einführung}
  \begin{enumerate}
    \item Definieren Sie die Begriffe "embedded system", "cyber-physical system (CPS)", "Internet of Things (IoT)", und "Industry 4.0".

          \begin{solution}
            Ein eingebettetes System ist ein Computersystem, das in einem größeren System eingebettet ist und spezielle Aufgaben erfüllt.

            Ein Cyber-Physical System (CPS) ist ein System, das die physische Welt mit der virtuellen Welt verbindet.

            Das Internet der Dinge (IoT) ist ein Netzwerk von miteinander verbundenen Geräten, die Daten austauschen und miteinander kommunizieren.

            Industrie 4.0 ist ein Konzept, das die Integration von Informationstechnologie und industrieller Produktion beschreibt.
          \end{solution}

    \item Warum benötigt man eingebettete Systeme?

          \begin{solution}
            Eingebettete Systeme werden benötigt, um spezielle Aufgaben in anderen Systemen zu erfüllen, wie z.B. in der Automobilindustrie, der Medizintechnik, und der Industrie.
          \end{solution}

    \item Welche Herausforderungen müssen überwunden werden, um die Chancen von eingebetteten Systemen voll auszuschöpfen?

          \begin{solution}
            Herausforderungen, die überwunden werden müssen, um die Chancen von eingebetteten Systemen voll auszuschöpfen, sind z.B. Echtzeitfähigkeit, Energieeffizienz, Ressourcenknappheit (Speicher, Prozessor), Kosten/Größe, Sicherheit (Safety \& Security), und Zuverlässigkeit.
          \end{solution}

    \item Was sind harte und weiche Timing-Constraints?

          \begin{solution}
            Harte Timing-Constraints sind Timing-Anforderungen, die unbedingt eingehalten werden müssen, während weiche Timing-Constraints weniger streng sind und toleriert werden können.
          \end{solution}

    \item Was ist adaptives Sampling?

          \begin{solution}
            Adaptives Sampling ist eine Technik, bei der die Abtastrate eines Sensors an die Änderungen der Umgebung angepasst wird.
          \end{solution}

    \item Was sind die Hauptunterschiede zwischen PC-basierten Anwendungen und eingebetteten/CPS-Anwendungen?

          \begin{solution}
            Die Hauptunterschiede zwischen PC-basierten Anwendungen und eingebetteten/CPS-Anwendungen sind die Echtzeitfähigkeit, die Ressourcenknappheit, und die Energieeffizienz.
          \end{solution}

    \item Was ist ein reaktives System?

          \begin{solution}
            Ein reaktives System ist ein System, das auf externe Ereignisse reagiert und in Echtzeit agiert.
          \end{solution}

    \item Wie könnten Design Flows modelliert werden?

          \begin{solution}
            Design Flows können modelliert werden als eine Abfolge von Schritten, die zur Entwicklung eines eingebetteten Systems führen.
          \end{solution}

    \item Was ist das V-Modell?

          \begin{solution}
            Das V-Modell stellt den einen Entwicklungsprozess und hebt die Verbindung zwischen den Entwicklungsphasen und den Testphasen hervor.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{Spezifikationen \& Modellierung}
  \begin{enumerate}
    \item Was ist ein (Design-)Modell?

          \begin{solution}
            Ein (Design-)Modell ist eine vereinfachte Darstellung eines Systems, die verwendet wird, um das Verhalten und die Struktur des Systems zu beschreiben.
          \end{solution}

    \item Nennen Sie 6 Anforderungen an Spezifikations-/Modellierungssprachen für eingebettete Systeme!

          \begin{solution}
            Anforderungen an Spezifikations-/Modellierungssprachen für eingebettete Systeme sind z.B. Echtzeitfähigkeit, Energieeffizienz, Sicherheit, und Verständlichkeit. evtl. Skalierbarkeit, Wiederverwendbarkeit, aber weniger bei ES.
          \end{solution}

    \item Was ist ein "Model of Computation" (MoC)?

          \begin{solution}
            Ein "Model of Computation" (MoC) ist eine formale Beschreibung der Berechnung, die verwendet wird, um das Verhalten von Systemen zu modellieren.
          \end{solution}

    \item Wie kann man einen Job von einem Task unterscheiden?

          \begin{solution}
            Ein Job ist eine Einheit von Arbeit, die von einem Prozessor ausgeführt wird, während ein Task eine abstrakte Einheit von Arbeit ist, die von einem Prozessor ausgeführt werden kann.
          \end{solution}

    \item Besschreiben Sie zwei Schlüsseltechniken für die Kommunikation in Computern!

          \begin{solution}
            Zwei Schlüsseltechniken für die Kommunikation in Computern sind Shared Memory und Message Passing.

            Shared Memory: Shared Memory ist eine Kommunikationstechnik, bei der mehrere Prozesse auf gemeinsame Speicherbereiche zugreifen können.

            Message Passing: Message Passing ist eine Kommunikationstechnik, bei der Prozesse Nachrichten austauschen, um Daten zu übertragen.
          \end{solution}

    \item Beschreiben Sie Techniken, die für die Erfassung von Anfangsideen über das zu entwerfende System verwendet werden können!

          \begin{solution}
            Techniken, die für die Erfassung von Anfangsideen über das zu entwerfende System verwendet werden können, sind z.B. Brainstorming, Mind Mapping, und Prototyping.

            Brainstorming: Brainstorming ist eine kreative Technik, bei der Ideen gesammelt und diskutiert werden, um neue Lösungen zu finden.

            Mind Mapping: Mind Mapping ist eine visuelle Technik, bei der Ideen und Konzepte in einem Diagramm dargestellt werden, um Zusammenhänge zu verdeutlichen.

            Prototyping: Prototyping ist eine Technik, bei der ein Modell oder eine Simulation des Systems erstellt wird, um das Design zu überprüfen und zu verbessern.
          \end{solution}

    \item Erläutern Sie StateCharts näher! Was ist StateMate in diesem Kontext?

          \begin{solution}
            StateCharts sind eine Erweiterung von endlichen Automaten (auch State Machines). Sie erlauben die Modellierung von Zuständen, Übergängen und Aktionen. Die maßgeblichen Erweiterungen sind hierbei Hierarchie und Parallelität.

            StateMate ist ein Werkzeug zur Modellierung von StateCharts.
          \end{solution}

    \item Nennen Sie einige Beispiele für asynchrone Kommunikation!

          \begin{solution}
            E-Mail, Instant Messaging. Im Kontext SDL, Kahn networks, P/T nets.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{Hardware}
  \begin{enumerate}
    \item Was ist ein Signal?

          \begin{solution}
            Ein Signal ist eine physikalische Größe, die Informationen überträgt und verarbeitet.
          \end{solution}

    \item Welchen Schaltkreis benötigen wir für den Übergang von kontinuierlicher Zeit zu diskreter Zeit?

          \begin{solution}
            Wir benötigen einen Sample-and-Hold-Schaltkreis für den Übergang von kontinuierlicher Zeit zu diskreter Zeit.
          \end{solution}

    \item Was besagt das Abtasttheorem?

          \begin{solution}
            Das Abtasttheorem besagt, dass ein Signal korrekt rekonstruiert werden kann, wenn es mit einer Rate abgetastet wird, die mindestens doppelt so hoch ist wie die höchste Frequenzkomponente des Signals.
          \end{solution}

    \item Was versteht man unter Quantization Noise?

          \begin{solution}
            Quantization Noise ist das Rauschen, das durch die Diskretisierung eines analogen Signals in ein digitales Signal entsteht.
          \end{solution}

    \item Was sind die Merkmale von DSP?

          \begin{solution}
            DSP (Digital Signal Processors) sind speziell für die Verarbeitung von Signalen und Daten optimiert und zeichnen sich durch hohe Leistung, Energieeffizienz, und Flexibilität aus.
          \end{solution}

    \item Aus welchen Komponenten bestehen FPGAs? Welche davon werden verwendet, um Boolesche Funktionen zu implementieren? Wie werden FPGAs konfiguriert? Sind FPGAs energieeffizient? Für welche Anwendungen sind FPGAs gut geeignet?

          \begin{solution}
            FPGAs bestehen aus Logikblöcken, Speicherblöcken und Verbindungen.

            Logikblöcke werden verwendet, um Boolesche Funktionen zu implementieren.

            FPGAs werden mit einem Konfigurations-Bitstrom konfiguriert.

            FPGAs sind energieeffizient und eignen sich gut für Anwendungen, die hohe Leistung und Flexibilität erfordern.
          \end{solution}

    \item Was ist ein VLIW-Prozessor?

          \begin{solution}
            Ein VLIW-Prozessor (Very Long Instruction Word) ist ein Prozessor, der mehrere Instruktionen in einem Taktzyklus ausführt.
          \end{solution}

    \item Was versteht man unter einer "Single-ISA heterogeneous multi-core architecture"? Welche Vorteile sehen Sie für eine solche Architektur?

          \begin{solution}
            Eine "Single-ISA heterogeneous multi-core architecture" ist eine Architektur, bei der mehrere Prozessoren mit unterschiedlichen Eigenschaften auf einem Chip integriert sind.

            Vorteile einer solchen Architektur sind z.B. die Möglichkeit, verschiedene Anwendungen auf einem Chip auszuführen, die Verbesserung der Leistung und Energieeffizienz, und die Flexibilität bei der Anpassung an unterschiedliche Anforderungen.
          \end{solution}

    \item Was ist der Unterschied zwischen einer GPU und einem MPSoC?

          \begin{solution}
            Eine GPU ist ein Prozessor, der für die Verarbeitung von Grafiken optimiert ist, während ein MPSoC ein Multiprozessorsystem auf einem Chip ist, das für die Verarbeitung von Signalen und Daten optimiert ist.
          \end{solution}

    \item Im Kontext von Speichern sagen wir manchmal "klein ist schön". Was könnte der Grund dafür sein?

          \begin{solution}
            Der Grund dafür ist, dass kleinere Speicher schneller und energieeffizienter sind als größere Speicher.
          \end{solution}

    \item  Einige Ebenen der Speicherhierarchie können dem Anwendungsprogrammierer verborgen sein. Warum sollte sich ein solcher Programmierer dennoch für die Architektur solcher Ebenen interessieren?

          \begin{solution}
            Ein Programmierer sollte sich für die Architektur solcher Ebenen interessieren, um die Leistung und Energieeffizienz seines Programms zu optimieren.
          \end{solution}

    \item Was ist Scratchpad Memory? Wie können wir sicherstellen, dass ein bestimmtes Speicherobjekt im Scratchpad Memory gespeichert wird?

          \begin{solution}
            Scratchpad Memory ist ein kleiner, schneller und energieeffizienter Speicher, der zur Speicherung häufig verwendeter Daten verwendet wird.

            Um sicherzustellen, dass ein bestimmtes Speicherobjekt im Scratchpad Memory gespeichert wird, können wir den
          \end{solution}

    \item Wie unterscheiden sich verschiedene Hardware-Technologien hinsichtlich ihrer Energieeffizienz?

          \begin{solution}
            FPGAs sind energieeffizienter als GPUs und MPSoCs, da sie speziell für die Verarbeitung von Signalen und Daten optimiert sind.
          \end{solution}

    \item Welche Herausforderungen bestehen für die Sicherheit von eingebetteten Systemen?

          \begin{solution}
            Betriebssysteme sind zB. weniger auf Sicherheit ausgelegt (Interrupts, direkter Hardwarezugriff). Auch die Kommunikation zwischen den Komponenten kann ein Sicherheitsrisiko darstellen.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{Software}
  \begin{enumerate}
    \item Welche Anforderungen müssen für ein eingebettetes Betriebssystem erfüllt sein?

          \begin{solution}
            Anforderungen für ein eingebettetes Betriebssystem sind z.B. Echtzeitfähigkeit, geringer Speicherbedarf, und Energieeffizienz.
          \end{solution}

    \item Welche Techniken können verwendet werden, um ein eingebettetes Betriebssystem auf die erforderliche Weise anzupassen?

          \begin{solution}
            Häufig verwendet werden Techniken wie Konfigurationsoptionen, Modulare Architektur, und Anpassung der Betriebssystemkomponenten.
          \end{solution}

    \item Welche Anforderungen müssen für ein Echtzeit-Betriebssystem erfüllt sein? Wie unterscheiden sie sich von den Anforderungen eines Standard-Betriebssystems? Welche Funktionen eines Standard-Betriebssystems wie Windows oder Linux könnten in einem RTOS fehlen?

          \begin{solution}
            Anforderungen für ein Echtzeit-Betriebssystem sind konkret Vorhersagbarkeit bzw. Determinismus, Timing-Management, und Geschwindigkeit bzw. geringe Latenzzeiten.

            Echtzeit-Betriebssysteme unterscheiden sich von Standard-Betriebssystemen durch ihre Echtzeitfähigkeit und ihre geringen Speicheranforderungen. Funktionen eines Standard-Betriebssystems wie Windows oder Linux, die in einem RTOS fehlen könnten, sind z.B. Multitasking, Dateisysteme, und Netzwerkunterstützung.
          \end{solution}

    \item Geben Sie ein Beispiel, das die Prioritätsinversion für ein System mit drei Jobs zeigt! Wie kann sich die Prioritätsinversion auf das System auswirken?

          \begin{solution}
            Drei Tasks (H, M, L) mit absteigender Priorität sollen ausgeführt werden. H und L benötigen exklusiven Zugriff auf Ressource R. L erhält zunächst Zugriff auf R, wird jedoch von M unterbrochen. Dadurch kann L die Ressource nicht freigeben und H muss warten. Dies führt zu einer Prioritätsinversion, bei der der höher priorisierte Task H blockiert wird und  uU. nicht rechtzeitig ausgeführt werden kann.
          \end{solution}

    \item Welche Ressourcenzugriffsprotokolle verhindern Deadlocks, die durch exklusiven Zugriff auf Ressourcen verursacht werden?

          \begin{solution}
            PCP: Das Priority Ceiling Protocol verhindert Deadlocks, die durch exklusiven Zugriff auf Ressourcen verursacht werden, indem es die Priorität eines Prozesses erhöht, wenn er auf eine Ressource wartet, die von einem anderen Prozess verwendet wird.

            Banker's Algorithm: Der Banker's Algorithmus verhindert Deadlocks, die durch exklusiven Zugriff auf Ressourcen verursacht werden, indem er sicherstellt, dass Prozesse nur auf Ressourcen zugreifen, die verfügbar sind.

            Wait-Die: Das Wait-Die-Protokoll verhindert Deadlocks, die durch exklusiven Zugriff auf Ressourcen verursacht werden, indem es Prozesse in Wartezustände versetzt, wenn sie auf Ressourcen warten, die von anderen Prozessen verwendet werden.
          \end{solution}
  \end{enumerate}
\end{exercise}

\begin{exercise}{Weitere Kapitel}
  \begin{enumerate}
    \item Welche Bedingungen müssen bei der Berechnung der WCET erfüllt sein?

          \begin{solution}
            Bedingungen, die bei der Berechnung der WCET (Worst Case Execution Time) erfüllt sein müssen, sind z.B. deterministische Ausführungszeiten, keine Interrupts, und keine Caches.
          \end{solution}

    \item Loop Unrolling ist eine der potenziell nützlichen Optimierungen. Nennen Sie bitte zwei potenzielle Vorteile und zwei potenzielle Probleme!

          \begin{solution}
            Potenzielle Vorteile von Loop Unrolling sind die Reduzierung des Overheads von Schleifen und die Erhöhung der Parallelität von Instruktionen.

            Potenzielle Probleme von Loop Unrolling sind die Erhöhung des Speicherbedarfs und die Erhöhung der Codegröße.
          \end{solution}

    \item Angenommen, Sie möchten Loop Tiling verwenden. Wie können Sie das Tiling an die vorliegende Speicherarchitektur anpassen?

          \begin{solution}
            Die Größe der Tiles könnte an die Größe des Caches angepasst werden, um die Cache-Effizienz zu maximieren.
          \end{solution}

    \item Für welche Architekturen würden Sie die größten Vorteile von einem Austausch von Gleitkomma-Arithmetik durch Festkomma-Arithmetik erwarten?

          \begin{solution}
            Die größten Vorteile würden in Architekturen mit begrenztem Speicherplatz und begrenzter Rechenleistung erwartet, z.B. in eingebetteten Systemen und mobilen Geräten.
          \end{solution}
  \end{enumerate}
\end{exercise}

\end{document}