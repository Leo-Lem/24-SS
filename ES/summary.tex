\documentclass{article}

\usepackage{summary}

\subject{Eingebettete Systeme}
\semester{Summer 2024}
\author{Leopold Lemmermann}

\begin{document}\createtitle

\section{Specification \& Modelling}

\subsection{General requirements}
\begin{enumerate}
  \item \textbf{Hierarchy}: behavioral, structural
  \item \textbf{Component-based}: esp. concurrency, communcation
  \item \textbf{Timing} (Burns, 1990): Measure time, delay, timeout, deadlines
  \item \textbf{Reactivity}: State-oriented, event-driven, exception-oriented
  \item …
\end{enumerate}

\subsection{Dependence graphs}
\begin{enumerate}
  \item \textbf{Directed graph}: nodes are operations/programs, edges are dependencies
  \item \textbf{Timing}: Arrival times, deadlines (for example)
  \item \textbf{I/O}: marked places
  \item \textbf{Shared resources}: small box
  \item \textbf{Periodicity}: $j_{n-1} \rightarrow j_n$
  \item \textbf{Hierarchy}: subgraphs
\end{enumerate}

\subsection{Problems with von-Neumann computing}
Mutual exclusion, holding resources while waiting for more, no preemption, circular wait.
$\hookrightarrow$ thread-based von-Neumann computation is inadquate for embedded systems. We need a more structured approach.

\subsection{Models of computation and message passing}
\begin{enumerate}
  \item \textbf{Undefined components}: plain text, use cases, sequence charts
  \item \textbf{Communicating FSM} (StateCharts for shared memory): async with SDL
  \item \textbf{Data flow} (architecutre for shared memory): async with Kahn networks/SDF
  \item \textbf{Petri nets}: C/E nets, P/T nets
  \item \textbf{Discrete event model} (VHDL, Verilog, Systemc, … for shared memory): only experimental systems
  \item \textbf{von Neumann model}: C, C++, Java, …
\end{enumerate}

\end{document}