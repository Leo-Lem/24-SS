\documentclass{article}

\usepackage{summary}

\subject{Eingebettete Systeme}
\semester{Summer 2024}
\author{Leopold Lemmermann}

\begin{document}\createtitle

\section{Specification \& Modelling}

\subsection{Overview}
\subsubsection{General requirements}
\begin{enumerate}
  \item \textbf{Hierarchy}: behavioral, structural
  \item \textbf{Component-based}: esp. concurrency, communcation
  \item \textbf{Timing} (Burns, 1990): Measure time, delay, timeout, deadlines
  \item \textbf{Reactivity}: State-oriented, event-driven, exception-oriented
  \item …
\end{enumerate}

\subsubsection{Dependence graphs}
\begin{enumerate}
  \item \textbf{Directed graph}: nodes are operations/programs, edges are dependencies
  \item \textbf{Timing}: Arrival times, deadlines (for example)
  \item \textbf{I/O}: marked places
  \item \textbf{Shared resources}: small box
  \item \textbf{Periodicity}: $j_{n-1} \rightarrow j_n$
  \item \textbf{Hierarchy}: subgraphs
\end{enumerate}

\subsubsection{Models of computation and message passing}
\begin{enumerate}
  \item \textbf{Undefined components}: plain text, use cases, sequence charts
  \item \textbf{Communicating FSM} (StateCharts for shared memory): async with SDL
  \item \textbf{Data flow} (architecutre for shared memory): async with Kahn networks/SDF
  \item \textbf{Petri nets}: C/E nets, P/T nets
  \item \textbf{Discrete event model} (VHDL, Verilog, Systemc, … for shared memory): only experimental systems
  \item \textbf{von Neumann model}: C, C++, Java, …
\end{enumerate}

\subsection{Early design phase (undefined components)}
\begin{enumerate}
  \item \textbf{Plain text}: describe system in natural language
  \item \textbf{Use cases}: describe system from user perspective (possible applications), included in UML
  \item \textbf{(Message) Sequence charts (MSCs)}: describe interaction between components, included in UML
  \item \textbf{UML timing diagrams}
  \item \textbf{Life sequence charts (LSCs)}: extend MSCs with pre-charts, mandatory- vs provisional behavior
\end{enumerate}

\subsubsection{Pros \& Cons of MSCs}
\begin{itemize}
  \item[+] Appropriate for visualising schedules
  \item[+] Proved method for transporting schedules
  \item[+] Standard defined (ITU-TS)
  \item[+] Semantics defined (ITU-TS)
  \item[-] just one case, no timing tolerances
\end{itemize}

\subsection{Communicating FSMs}
see RSB/MAKS for introduction

\subsubsection{Definitions}
\begin{itemize}
  \item \textbf{Clock constraints}: conjunctive formula of atomic constraints $x-y \leq|<|=|>|\geq n\forall x,y\in C, n\in \mathbb{N}$
  \item \textbf{Timed automaton}: FSM with clock constraints
\end{itemize}

\subsubsection{StateCharts}
\begin{quote} based in shared memory computation, aggregates FSMs, allows for hierarchy, concurrency, communication, …\end{quote}

\begin{itemize}
  \item \textbf{Active states}: states with active substates
  \item \textbf{Basic states}: not composed of substates
  \item \textbf{Superstates}: composed of substates
  \item \textbf{OR-superstates} (choice): one of the substates is active
  \item \textbf{AND-superstates} (concurrency): all substates are active
  \item \textbf{History states}: remember last active substate
  \item \textbf{Timers}: special timeout edges
  \item \textbf{Edge labels}: event [condition]/action
  \item \textbf{StateMate simulation}
        \begin{enumerate}
          \item effect of external changes on events and conditions
          \item set of transitions enabled by events and right-hand side are computed
          \item transitions become active, new values for variables
        \end{enumerate}
  \item \textbf{Event lifetime}: live until step following is generated
  \item \textbf{Determinate}: given all conflicts resolved and no undefined behavior
\end{itemize}

\subsubsection{Pros \& Cons of StateCharts}
\begin{itemize}
  \item[+] arbitrary nesting of AND- \& OR-superstates
  \item[+] (StateMate-)Semantics defined
  \item[+] large number of commercial simulation tools
  \item[+] translation to SW/HW possible
  \item[-] not useful for distributed applications
  \item[-] no program constructs
  \item[-] no description of non-functional behavior
  \item[-] no object-orientation
  \item[-] no description of structural hierarchy
  \item[-] (possibly) inefficient generated programms
\end{itemize}

\subsubsection{message passing between FSMs via Specification \& Description language (SDL)}
\begin{quote} Excellent for distributed systems, asynchronous message passing, based on CFSM (like StateCharts) \end{quote}

\begin{itemize}
  \item \textbf{Process}: with State (round rectangle), Input (anti left arrow), Output (anti right arrow)
  \item \textbf{FIFO messaging}: between processes
  \item \textbf{Interaction}: process interaction diagrams
  \item \textbf{Hierarchy}: blocks, root block (system), block instance (processes cannot contain other processes)
\end{itemize}

\subsection{Data flow}

\subsubsection{Elements}
\begin{itemize}
  \item \textbf{Processes}: activites transforming data
  \item \textbf{Data stores}: holding areas for data
  \item \textbf{External entities}: sending/receiving data
  \item \textbf{Data flow}: data movement
\end{itemize}

\subsubsection{Kahn process networks (KPNs)}
\begin{quote}Components modeled as processes, connected by 1to1 FIFO channels (writes never wait, reads never block).\end{quote}

\begin{itemize}
  \item[+] processes have to commit to wait for data
  \item[+] order of reads and writes is irrelevant $\to$ determinate
  \item Turing-complete
  \item[-] timing not modeled
  \item[-] static process number
\end{itemize}

\subsubsection{Synchronous data flow (SDF)}
\begin{quote}KPN with fixed number of processes, each process has fixed number of inputs and outputs, each input/output has fixed rate.\end{quote}

\begin{itemize}
  \item[+] timing can be modeled
  \item[-] not Turing-complete
\end{itemize}

\subsection{Petri nets}
see MAKS

\subsubsection{Pros \& Cons}
\begin{itemize}
  \item[+] Appropriate for distributed applications
  \item[+] Well-known theory for formally proving properties
  \item[+] Initially a quite bizarre topic, but now accepted due to increasing number of distributed applications
  \item[-] problems with modeling timing
  \item[-] no programming elements
  \item[-] no hierarchy
  \item[ext.] enormous amounts of effort on removing limitations
\end{itemize}

\subsection{Discrete event models}

\begin{quote}Queue of future events, fetch \& execute cycle.\end{quote}
\subsubsection{Very High Speed Integrated Circuit VHSIC Hardware Description Language (VHDL)}
\begin{quote}Used for modeling digital circuits, based on Ada, used for simulation and synthesis.\end{quote}

\subsubsection{Pros \& Cons}
\begin{itemize}
  \item[+] Behavioral hierarchy (procedures and functions)
  \item[+] Structural hierarchy: through structural architectures, but no nested processes
  \item[-] No specification of non-functional properties
  \item[-] No object-orientation
  \item[-] Static number of processes, static evaluation
  \item[-] Complicated simulation semantics
  \item[-] Too low level for initial specification
  \item[$\hookrightarrow$] Good as an intermediate “Esperanto“ or ”assembly” language for hardware generation
\end{itemize}

\subsection{Imperative computation}
\begin{quote}Based on von-Neumann architecture, sequential execution, shared memory, C/C++/Java/…\end{quote}

\subsubsection{Problems with von-Neumann computing}
Mutual exclusion, holding resources while waiting for more, no preemption, circular wait.
\par $\hookrightarrow$ thread-based von-Neumann computation is inadquate for embedded systems.

\subsection{Comparison}
\input{res/modelcomp.tbl}

\subsubsection{Stuijk classification}
\begin{enumerate}
  \item expressive- \& succinctness: which systems can be modeled, how compact they are
  \item analyzability: availability of scheduling, need for run-time support
  \item implementation: required scheduling policy, code size
\end{enumerate}

There is a trade-off between expressiveness and analyzability.

\subsubsection{Mixing models}

\begin{itemize}
  \item Ptolomy \& UML: UML for structure, Ptolomy for behavior
  \item FSM/KPN in imperative languages: FSM/KPN for structure, imperative for behavior
\end{itemize}



\section{Hardware}




\section{Software}




\section{Evaluation \& Validation}




\section{Mapping Applications to Platforms}


\end{document}